<?php

namespace Dr\MarketBundle\Entity;

use Doctrine\ORM\EntityRepository;
use Dr\MarketBundle\Entity\TradingPair;
use Dr\MarketBundle\Entity\Market;

/**
 * TradeRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */

class TradeRepository extends EntityRepository
{
    /**
     * @param Market $market
     * @param TradingPair $pair
     * @return Trade
     */
    public function getLastTrade(Market $market, TradingPair $pair){
        return $this->createQueryBuilder('t')
                ->select('t')
                ->where('t.remoteId IS NOT null')
                ->andWhere('t.market = :market_id')
                ->andWhere('t.tradingPair = :tp_id')
                ->orderBy('t.id', 'DESC')
                ->setParameter('market_id', $market->getId() )
                ->setParameter('tp_id', $pair->getId())
                ->setMaxResults(1)
                ->getQuery()->getOneOrNullResult()
                ;
    }

    
    /**
     * weighted average trading price
     * @param Market $market
     * @param TradingPair $pair
     * @param integer $interval (in seconds)
     * @return array
     */
    public function getWeightedData(Market $market, TradingPair $pair, $interval = 300, $offset = 0, $limit = 10){
        $sql = 'SELECT 
            (SUM(wPrice) / SUM(volume)) vwap,
            SUM(volume) as volume,
            MIN(timeRemote) as period,
            COUNT(id) as nTrades
            FROM (
                SELECT (volume * price) as wPrice,
                price, volume, timeRemote, market_id, tradingPair_id, id
                FROM trade) as vTrade
            WHERE market_id = :m_id
            AND tradingPair_id = :t_id
            GROUP BY ROUND(UNIX_TIMESTAMP(timeRemote) / :interval)
            LIMIT p_limit;
            ';
        
        $statement = $this->getEntityManager()->getConnection()->executeQuery($sql, array(
            'm_id' => $market->getId(),
            't_id' => $pair->getId(),
            'interval' => $interval,
//            'p_offset' => $offset,
//            'p_limit' => $limit
        ));
        
        return $statement->fetchAll();
    }
    
    /**
     * Returns OHLC data
     * @param Market $market
     * @param TradingPair $pair
     * @param integer $interval number of seconds
     * @return array
     */
    public function getOHLCData(Market $market, TradingPair $pair, $interval = 300){
                $sql = '
        SELECT virtual.vwap, virtual.volume, virtual.nTrades, virtual.period, virtual.high, virtual.low, tr1.price as open, tr2.price as close,
        UNIX_TIMESTAMP(virtual.period) as period_unix
        FROM 
        (
            SELECT (SUM(wPrice)/ SUM(volume)) AS vwap,
            SUM(volume) AS volume,
            COUNT(id) AS nTrades,
            MAX(timeRemote) as period,
            MAX(price) as high,
            MIN(price) as low,
            MIN(id) as op_id,
            MAX(id) as cl_id
            FROM (
            SELECT (volume * price) as wPrice,
            price, volume, timeRemote, market_id, tradingPair_id, id
            FROM trade) as vTrade
            WHERE market_id = :m_id
            AND tradingPair_id = :t_id
            GROUP BY ROUND(UNIX_TIMESTAMP(timeRemote) / :interval)
        )as virtual
        INNER JOIN trade as tr1 on op_id = tr1.id 
        INNER JOIN trade as tr2 on cl_id = tr2.id
            ';
        
        $statement = $this->getEntityManager()->getConnection()->executeQuery($sql, array(
            'm_id' => $market->getId(),
            't_id' => $pair->getId(),
            'interval' => $interval,
        ));
        
        return $statement->fetchAll();
    }
    
    /**
     * This method will return the averaged data for each $interval
     * @param Market $market
     * @param TradingPair $pair
     * @param type $interval (seconds)
     */
    public function getNormalizedData(Market $market, TradingPair $pair, $interval = 3600){
        
    }
    
}
